 -- CAREFUL! drop previously backed up tables in savemgr
 DECLARE

  l_backup_tables bpmmgr.varchar2_list_type := bpmmgr.varchar2_list_type(
    'CONSULTEE_GROUP_TEAM_MEMBERS'
    ,'DOCUMENT_TEMPLATES'
    ,'DT_SECTIONS'
    ,'DT_SECTION_CLAUSES'
    ,'DT_SECTION_CLAUSE_VERSIONS'
    ,'MAIL_MERGE_FIELDS'
    ,'TEMPLATE_TEXT'
    );

BEGIN

  FOR backup_table IN (
    SELECT column_value table_name
    FROM TABLE(l_backup_tables)
  ) LOOP
    DECLARE
    l_text VARCHAR2(4000) := 'DROP TABLE '|| 'savemgr."'||backup_table.table_name||'bk" ';
    BEGIN
    dbms_output.put_line(l_text);
      EXECUTE IMMEDIATE (l_text);
    END;
  END LOOP;
END;
/

-- backup tables in specific schema to single savemgre tables. careful not to overwrite data by accident
DECLARE
  l_backup_schema VARCHAR2(400) := 'PWA';

  l_backup_tables bpmmgr.varchar2_list_type := bpmmgr.varchar2_list_type(
    'CONSULTEE_GROUP_TEAM_MEMBERS'
    ,'DOCUMENT_TEMPLATES'
    ,'DT_SECTIONS'
    ,'DT_SECTION_CLAUSES'
    ,'DT_SECTION_CLAUSE_VERSIONS'
    ,'MAIL_MERGE_FIELDS'
    ,'TEMPLATE_TEXT'
    );

BEGIN

  FOR backup_table IN (
    SELECT column_value table_name
    FROM TABLE(l_backup_tables)
  ) LOOP
    BEGIN
      savemgr.savetool.table_save(
          p_owner => 'PWA'
        , p_name => backup_table.table_name
        , p_suffix => 'bk'
        , p_tablespace => 'TBSDATA'
        );
    EXCEPTION WHEN OTHERS THEN
      dbms_output.put_Line('Could not backup table: ' || l_backup_schema || '.' || backup_table.table_name || CHR(10) || SQLERRM || CHR(10) || dbms_utility.format_error_backtrace());
    END;
  END LOOP;
END;
/

-- create a script in the dbms_output to restore data from saved tables
DECLARE
  l_backup_schema VARCHAR2(400) := :p_backup_schema_uppercase;
  l_backup_table_suffix VARCHAR2(400) := 'bk';

  l_backup_tables bpmmgr.varchar2_list_type := bpmmgr.varchar2_list_type(
     'CONSULTEE_GROUP_TEAM_MEMBERS'
    ,'DOCUMENT_TEMPLATES'
    ,'DT_SECTIONS'
    ,'DT_SECTION_CLAUSES'
    ,'DT_SECTION_CLAUSE_VERSIONS'
    ,'MAIL_MERGE_FIELDS'
    ,'TEMPLATE_TEXT'
    );

BEGIN

  FOR backup_table IN (
    SELECT column_value table_name
    -- order is important so tables restored in an foreign key friendly order
    FROM TABLE(l_backup_tables)
    ) LOOP
      DECLARE

        l_restore_column_names bpmmgr.varchar2_list_type;
        
        l_backup_table_src_merge_text VARCHAR2(32000);
        
        l_backup_table_dest_ref VARCHAR2(200) := l_backup_schema || '.' || backup_table.table_name;
        l_backup_table_src_ref VARCHAR2(200) := 'savemgr."' || backup_table.table_name || l_backup_table_suffix||'"';
        l_first_col BOOLEAN := TRUE;
        l_pk_column VARCHAR2(200);
        l_table_pk_modify VARCHAR2(4000);
        l_table_pk_reset VARCHAR2(4000);
        
        l_pk_column_is_identity VARCHAR2(100);
        
        l_delete_from VARCHAR2(4000);
        
      BEGIN
      
        dbms_output.put_line('-- Processing: ' || l_backup_table_dest_ref);
        
        SELECT column_name
        BULK COLLECT INTO l_restore_column_names
        FROM all_tab_columns 
        WHERE table_name = backup_table.table_name
        AND owner = l_backup_schema
        ORDER BY column_id ASC;
        
        -- need to allow our dest table to have IDs inserted so foreign keys match.
        l_pk_column := l_restore_column_names(1);
        
        SELECT identity_column
        INTO l_pk_column_is_identity
        FROM all_tab_columns 
        WHERE table_name = backup_table.table_name
        AND owner = l_backup_schema
        AND column_name = l_pk_column;
        
        IF(l_pk_column_is_identity = 'YES') THEN       
          l_table_pk_modify := 'ALTER TABLE ' || l_backup_table_dest_ref || ' MODIFY ' || l_pk_column || '  GENERATED BY DEFAULT AS IDENTITY;' || CHR(10);
          dbms_output.put_line(l_table_pk_modify);
        END IF;
        
        
        -- delete from table where id not in source table
        l_delete_from := 'DELETE FROM ' || l_backup_table_dest_ref || ' WHERE ' || l_pk_column || ' NOT IN (SELECT ' || l_pk_column || ' FROM ' || l_backup_table_src_ref ||  ');' || CHR(10);
        dbms_output.put_line(l_delete_from);
        
        -- create merge statement
        l_backup_table_src_merge_text := 'MERGE INTO ' || l_backup_table_dest_ref || ' dest ' || CHR(10) ||
          'USING ' ||  l_backup_table_src_ref || ' src ' || CHR(10) ||
          'ON ( src.' || l_pk_column || ' = dest.' || l_pk_column || ')' || CHR(10) ||
          'WHEN MATCHED THEN ' || CHR(10) ||' UPDATE SET ' || CHR(10);
        
        -- populate update conditions  
        FOR backup_column IN(
          SELECT column_value col_name
          FROM TABLE(l_restore_column_names)
        ) LOOP
          
          IF(l_first_col) 
          THEN
            l_backup_table_src_merge_text := l_backup_table_src_merge_text || 'dest.' || backup_column.col_name || ' = src.' || backup_column.col_name || CHR(10);
          ELSE
            l_backup_table_src_merge_text := l_backup_table_src_merge_text || ', dest.' || backup_column.col_name || ' = src.' || backup_column.col_name || CHR(10);
          END IF;
          
          l_first_col := FALSE;
            
        END LOOP;
        
        -- populate insert conditions  
        l_backup_table_src_merge_text := l_backup_table_src_merge_text || ' WHEN NOT MATCHED INSERT (' ||
          st.join(p_strings=>l_restore_column_names, p_delimiter=> ',') || ')' || CHR(10) || 
          'src.' || st.join(p_strings=>l_restore_column_names, p_delimiter => ', src.') || ')' || CHR(10);
        

        dbms_output.put_line(l_backup_table_src_merge_text || ';' || CHR(10));
        
        IF(l_pk_column_is_identity = 'YES') THEN
          --Change the identity column back to generated always. 
          --And set its start value to the max id in the table + 1.
          l_table_pk_reset := 'ALTER TABLE ' || l_backup_table_dest_ref || ' MODIFY ' || l_pk_column || '  GENERATED ALWAYS AS IDENTITY (START WITH limit value)';       
          dbms_output.put_line(l_table_pk_reset);
        END IF;

    END;
    END LOOP;
END;
/